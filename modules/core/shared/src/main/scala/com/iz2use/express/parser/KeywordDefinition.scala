package com.iz2use.express.parser

import scala.language.postfixOps
import fastparse.all._

trait KeywordDefinition {
  private[parser] val ABS = P(("ABS").opaque("ABS"))
  private[parser] val ABSTRACT = P(("ABSTRACT").opaque("ABSTRACT"))
  private[parser] val ACOS = P(("ACOS").opaque("ACOS"))
  private[parser] val AGGREGATE = P(("AGGREGATE").opaque("AGGREGATE"))
  private[parser] val ALIAS = P(("ALIAS").opaque("ALIAS"))
  private[parser] val AND = P(("AND").opaque("AND"))
  private[parser] val ANDOR = P(("ANDOR").opaque("ANDOR"))
  private[parser] val ARRAY = P(("ARRAY").opaque("ARRAY"))
  private[parser] val AS = P(("AS").opaque("AS"))
  private[parser] val ASIN = P(("ASIN").opaque("ASIN"))
  private[parser] val ATAN = P(("ATAN").opaque("ATAN"))
  private[parser] val BAG = P(("BAG").opaque("BAG"))
  private[parser] val BASED_ON = P(("BASED_ON").opaque("BASED_ON"))
  private[parser] val BEGIN = P(("BEGIN").opaque("BEGIN"))
  private[parser] val BINARY = P(("BINARY").opaque("BINARY"))
  private[parser] val BLENGTH = P(("BLENGTH").opaque("BLENGTH"))
  private[parser] val BOOLEAN = P(("BOOLEAN").opaque("BOOLEAN"))
  private[parser] val BY = P(("BY").opaque("BY"))
  private[parser] val CASE = P(("CASE").opaque("CASE"))
  private[parser] val CONSTANT = P(("CONSTANT").opaque("CONSTANT"))
  private[parser] val CONST_E = P(("E").opaque("CONST_E"))
  private[parser] val COS = P(("COS").opaque("COS"))
  private[parser] val DERIVE = P(("DERIVE").opaque("DERIVE"))
  private[parser] val DIV = P(("DIV").opaque("DIV"))
  private[parser] val ELSE = P(("ELSE").opaque("ELSE"))
  private[parser] val END = P(("END").opaque("END"))
  private[parser] val END_ALIAS = P(("END_ALIAS").opaque("END_ALIAS"))
  private[parser] val END_CASE = P(("END_CASE").opaque("END_CASE"))
  private[parser] val END_CONSTANT = P(("END_CONSTANT").opaque("END_CONSTANT"))
  private[parser] val END_ENTITY = P(("END_ENTITY").opaque("END_ENTITY"))
  private[parser] val END_FUNCTION = P(("END_FUNCTION").opaque("END_FUNCTION"))
  private[parser] val END_IF = P(("END_IF").opaque("END_IF"))
  private[parser] val END_LOCAL = P(("END_LOCAL").opaque("END_LOCAL"))
  private[parser] val END_PROCEDURE = P(("END_PROCEDURE").opaque("END_PROCEDURE"))
  private[parser] val END_REPEAT = P(("END_REPEAT").opaque("END_REPEAT"))
  private[parser] val END_RULE = P(("END_RULE").opaque("END_RULE"))
  private[parser] val END_SCHEMA = P(("END_SCHEMA").opaque("END_SCHEMA"))
  private[parser] val END_SUBTYPE_CONSTRAINT = P(("END_SUBTYPE_CONSTRAINT").opaque("END_SUBTYPE_CONSTRAINT"))
  private[parser] val END_TYPE = P(("END_TYPE").opaque("END_TYPE"))
  private[parser] val ENTITY = P(("ENTITY").opaque("ENTITY"))
  private[parser] val ENUMERATION = P(("ENUMERATION").opaque("ENUMERATION"))
  private[parser] val ESCAPE = P(("ESCAPE").opaque("ESCAPE"))
  private[parser] val EXISTS = P(("EXISTS").opaque("EXISTS"))
  private[parser] val EXTENSIBLE = P(("EXTENSIBLE").opaque("EXTENSIBLE"))
  private[parser] val EXP = P(("EXP").opaque("EXP"))
  private[parser] val FALSE = P(("FALSE").opaque("FALSE"))
  private[parser] val FIXED = P(("FIXED").opaque("FIXED"))
  private[parser] val FOR = P(("FOR").opaque("FOR"))
  private[parser] val FORMAT = P(("FORMAT").opaque("FORMAT"))
  private[parser] val FROM = P(("FROM").opaque("FROM"))
  private[parser] val FUNCTION = P(("FUNCTION").opaque("FUNCTION"))
  private[parser] val GENERIC = P(("GENERIC").opaque("GENERIC"))
  private[parser] val GENERIC_ENTITY = P(("GENERIC_ENTITY").opaque("GENERIC_ENTITY"))
  private[parser] val HIBOUND = P(("HIBOUND").opaque("HIBOUND"))
  private[parser] val HIINDEX = P(("HIINDEX").opaque("HIINDEX"))
  private[parser] val IF = P(("IF").opaque("IF"))
  private[parser] val IN = P(("IN").opaque("IN"))
  private[parser] val INSERT = P(("INSERT").opaque("INSERT"))
  private[parser] val INTEGER = P(("INTEGER").opaque("INTEGER"))
  private[parser] val INVERSE = P(("INVERSE").opaque("INVERSE"))
  private[parser] val LENGTH = P(("LENGTH").opaque("LENGTH"))
  private[parser] val LIKE = P(("LIKE").opaque("LIKE"))
  private[parser] val LIST = P(("LIST").opaque("LIST"))
  private[parser] val LOBOUND = P(("LOBOUND").opaque("LOBOUND"))
  private[parser] val LOCAL = P(("LOCAL").opaque("LOCAL"))
  private[parser] val LOG = P(("LOG").opaque("LOG"))
  private[parser] val LOG10 = P(("LOG10").opaque("LOG10"))
  private[parser] val LOG2 = P(("LOG2").opaque("LOG2"))
  private[parser] val LOGICAL = P(("LOGICAL").opaque("LOGICAL"))
  private[parser] val LOINDEX = P(("LOINDEX").opaque("LOINDEX"))
  private[parser] val MOD = P(("MOD").opaque("MOD"))
  private[parser] val NOT = P(("NOT").opaque("NOT"))
  private[parser] val NUMBER = P(("NUMBER").opaque("NUMBER"))
  private[parser] val NVL = P(("NVL").opaque("NVL"))
  private[parser] val ODD = P(("ODD").opaque("ODD"))
  private[parser] val OF = P(("OF").opaque("OF"))
  private[parser] val ONEOF = P(("ONEOF").opaque("ONEOF"))
  private[parser] val OPTIONAL = P(("OPTIONAL").opaque("OPTIONAL"))
  private[parser] val OR = P(("OR").opaque("OR"))
  private[parser] val OTHERWISE = P(("OTHERWISE").opaque("OTHERWISE"))
  private[parser] val PI = P(("PI").opaque("PI"))
  private[parser] val PROCEDURE = P(("PROCEDURE").opaque("PROCEDURE"))
  private[parser] val QUERY = P(("QUERY").opaque("QUERY"))
  private[parser] val REAL = P(("REAL").opaque("REAL"))
  private[parser] val REFERENCE = P(("REFERENCE").opaque("REFERENCE"))
  private[parser] val REMOVE = P(("REMOVE").opaque("REMOVE"))
  private[parser] val RENAMED = P(("RENAMED").opaque("RENAMED"))
  private[parser] val REPEAT = P(("REPEAT").opaque("REPEAT"))
  private[parser] val RETURN = P(("RETURN").opaque("RETURN"))
  private[parser] val ROLESOF = P(("ROLESOF").opaque("ROLESOF"))
  private[parser] val RULE = P(("RULE").opaque("RULE"))
  private[parser] val SCHEMA = P(("SCHEMA").opaque("SCHEMA"))
  private[parser] val SELECT = P(("SELECT").opaque("SELECT"))
  private[parser] val SELF = P(("SELF").opaque("SELF"))
  private[parser] val SET = P(("SET").opaque("SET"))
  private[parser] val SIN = P(("SIN").opaque("SIN"))
  private[parser] val SIZEOF = P(("SIZEOF").opaque("SIZEOF"))
  private[parser] val SKIP = P(("SKIP").opaque("SKIP"))
  private[parser] val SQRT = P(("SQRT").opaque("SQRT"))
  private[parser] val STRING = P(("STRING").opaque("STRING"))
  private[parser] val SUBTYPE = P(("SUBTYPE").opaque("SUBTYPE"))
  private[parser] val SUBTYPE_CONSTRAINT = P(("SUBTYPE_CONSTRAINT").opaque("SUBTYPE_CONSTRAINT"))
  private[parser] val SUPERTYPE = P(("SUPERTYPE").opaque("SUPERTYPE"))
  private[parser] val TAN = P(("TAN").opaque("TAN"))
  private[parser] val THEN = P(("THEN").opaque("THEN"))
  private[parser] val TO = P(("TO").opaque("TO"))
  private[parser] val TOTAL_OVER = P(("TOTAL_OVER").opaque("TOTAL_OVER"))
  private[parser] val TRUE = P(("TRUE").opaque("TRUE"))
  private[parser] val TYPE = P(("TYPE").opaque("TYPE"))
  private[parser] val TYPEOF = P(("TYPEOF").opaque("TYPEOF"))
  private[parser] val UNIQUE = P(("UNIQUE").opaque("UNIQUE"))
  private[parser] val UNKNOWN = P(("UNKNOWN").opaque("UNKNOWN"))
  private[parser] val UNTIL = P(("UNTIL").opaque("UNTIL"))
  private[parser] val USE = P(("USE").opaque("USE"))
  private[parser] val USEDIN = P(("USEDIN").opaque("USEDIN"))
  private[parser] val VALUE = P(("VALUE").opaque("VALUE"))
  private[parser] val VALUE_IN = P(("VALUE_IN").opaque("VALUE_IN"))
  private[parser] val VALUE_UNIQUE = P(("VALUE_UNIQUE").opaque("VALUE_UNIQUE"))
  private[parser] val VAR = P(("VAR").opaque("VAR"))
  private[parser] val WHERE = P(("WHERE").opaque("WHERE"))
  private[parser] val WHILE = P(("WHILE").opaque("WHILE"))
  private[parser] val WITH = P(("WITH").opaque("WITH"))
  private[parser] val XOR = P(("XOR").opaque("XOR"))
}