package com.iz2use.express.parser

import scala.language.postfixOps
import fastparse.all._

trait KeywordDefinition {
  private[parser] val ABS = P(IgnoreCase("ABS").opaque("ABS"))
  private[parser] val ABSTRACT = P(IgnoreCase("ABSTRACT").opaque("ABSTRACT"))
  private[parser] val ACOS = P(IgnoreCase("ACOS").opaque("ACOS"))
  private[parser] val AGGREGATE = P(IgnoreCase("AGGREGATE").opaque("AGGREGATE"))
  private[parser] val ALIAS = P(IgnoreCase("ALIAS").opaque("ALIAS"))
  private[parser] val AND = P(IgnoreCase("AND").opaque("AND"))
  private[parser] val ANDOR = P(IgnoreCase("ANDOR").opaque("ANDOR"))
  private[parser] val ARRAY = P(IgnoreCase("ARRAY").opaque("ARRAY"))
  private[parser] val AS = P(IgnoreCase("AS").opaque("AS"))
  private[parser] val ASIN = P(IgnoreCase("ASIN").opaque("ASIN"))
  private[parser] val ATAN = P(IgnoreCase("ATAN").opaque("ATAN"))
  private[parser] val BAG = P(IgnoreCase("BAG").opaque("BAG"))
  private[parser] val BASED_ON = P(IgnoreCase("BASED_ON").opaque("BASED_ON"))
  private[parser] val BEGIN = P(IgnoreCase("BEGIN").opaque("BEGIN"))
  private[parser] val BINARY = P(IgnoreCase("BINARY").opaque("BINARY"))
  private[parser] val BLENGTH = P(IgnoreCase("BLENGTH").opaque("BLENGTH"))
  private[parser] val BOOLEAN = P(IgnoreCase("BOOLEAN").opaque("BOOLEAN"))
  private[parser] val BY = P(IgnoreCase("BY").opaque("BY"))
  private[parser] val CASE = P(IgnoreCase("CASE").opaque("CASE"))
  private[parser] val CONSTANT = P(IgnoreCase("CONSTANT").opaque("CONSTANT"))
  private[parser] val CONST_E = P(IgnoreCase("E").opaque("CONST_E"))
  private[parser] val COS = P(IgnoreCase("COS").opaque("COS"))
  private[parser] val DERIVE = P(IgnoreCase("DERIVE").opaque("DERIVE"))
  private[parser] val DIV = P(IgnoreCase("DIV").opaque("DIV"))
  private[parser] val ELSE = P(IgnoreCase("ELSE").opaque("ELSE"))
  private[parser] val END = P(IgnoreCase("END").opaque("END"))
  private[parser] val END_ALIAS = P(IgnoreCase("END_ALIAS").opaque("END_ALIAS"))
  private[parser] val END_CASE = P(IgnoreCase("END_CASE").opaque("END_CASE"))
  private[parser] val END_CONSTANT = P(IgnoreCase("END_CONSTANT").opaque("END_CONSTANT"))
  private[parser] val END_ENTITY = P(IgnoreCase("END_ENTITY").opaque("END_ENTITY"))
  private[parser] val END_FUNCTION = P(IgnoreCase("END_FUNCTION").opaque("END_FUNCTION"))
  private[parser] val END_IF = P(IgnoreCase("END_IF").opaque("END_IF"))
  private[parser] val END_LOCAL = P(IgnoreCase("END_LOCAL").opaque("END_LOCAL"))
  private[parser] val END_PROCEDURE = P(IgnoreCase("END_PROCEDURE").opaque("END_PROCEDURE"))
  private[parser] val END_REPEAT = P(IgnoreCase("END_REPEAT").opaque("END_REPEAT"))
  private[parser] val END_RULE = P(IgnoreCase("END_RULE").opaque("END_RULE"))
  private[parser] val END_SCHEMA = P(IgnoreCase("END_SCHEMA").opaque("END_SCHEMA"))
  private[parser] val END_SUBTYPE_CONSTRAINT = P(IgnoreCase("END_SUBTYPE_CONSTRAINT").opaque("END_SUBTYPE_CONSTRAINT"))
  private[parser] val END_TYPE = P(IgnoreCase("END_TYPE").opaque("END_TYPE"))
  private[parser] val ENTITY = P(IgnoreCase("ENTITY").opaque("ENTITY"))
  private[parser] val ENUMERATION = P(IgnoreCase("ENUMERATION").opaque("ENUMERATION"))
  private[parser] val ESCAPE = P(IgnoreCase("ESCAPE").opaque("ESCAPE"))
  private[parser] val EXISTS = P(IgnoreCase("EXISTS").opaque("EXISTS"))
  private[parser] val EXTENSIBLE = P(IgnoreCase("EXTENSIBLE").opaque("EXTENSIBLE"))
  private[parser] val EXP = P(IgnoreCase("EXP").opaque("EXP"))
  private[parser] val FALSE = P(IgnoreCase("FALSE").opaque("FALSE"))
  private[parser] val FIXED = P(IgnoreCase("FIXED").opaque("FIXED"))
  private[parser] val FOR = P(IgnoreCase("FOR").opaque("FOR"))
  private[parser] val FORMAT = P(IgnoreCase("FORMAT").opaque("FORMAT"))
  private[parser] val FROM = P(IgnoreCase("FROM").opaque("FROM"))
  private[parser] val FUNCTION = P(IgnoreCase("FUNCTION").opaque("FUNCTION"))
  private[parser] val GENERIC = P(IgnoreCase("GENERIC").opaque("GENERIC"))
  private[parser] val GENERIC_ENTITY = P(IgnoreCase("GENERIC_ENTITY").opaque("GENERIC_ENTITY"))
  private[parser] val HIBOUND = P(IgnoreCase("HIBOUND").opaque("HIBOUND"))
  private[parser] val HIINDEX = P(IgnoreCase("HIINDEX").opaque("HIINDEX"))
  private[parser] val IF = P(IgnoreCase("IF").opaque("IF"))
  private[parser] val IN = P(IgnoreCase("IN").opaque("IN"))
  private[parser] val INSERT = P(IgnoreCase("INSERT").opaque("INSERT"))
  private[parser] val INTEGER = P(IgnoreCase("INTEGER").opaque("INTEGER"))
  private[parser] val INVERSE = P(IgnoreCase("INVERSE").opaque("INVERSE"))
  private[parser] val LENGTH = P(IgnoreCase("LENGTH").opaque("LENGTH"))
  private[parser] val LIKE = P(IgnoreCase("LIKE").opaque("LIKE"))
  private[parser] val LIST = P(IgnoreCase("LIST").opaque("LIST"))
  private[parser] val LOBOUND = P(IgnoreCase("LOBOUND").opaque("LOBOUND"))
  private[parser] val LOCAL = P(IgnoreCase("LOCAL").opaque("LOCAL"))
  private[parser] val LOG = P(IgnoreCase("LOG").opaque("LOG"))
  private[parser] val LOG10 = P(IgnoreCase("LOG10").opaque("LOG10"))
  private[parser] val LOG2 = P(IgnoreCase("LOG2").opaque("LOG2"))
  private[parser] val LOGICAL = P(IgnoreCase("LOGICAL").opaque("LOGICAL"))
  private[parser] val LOINDEX = P(IgnoreCase("LOINDEX").opaque("LOINDEX"))
  private[parser] val MOD = P(IgnoreCase("MOD").opaque("MOD"))
  private[parser] val NOT = P(IgnoreCase("NOT").opaque("NOT"))
  private[parser] val NUMBER = P(IgnoreCase("NUMBER").opaque("NUMBER"))
  private[parser] val NVL = P(IgnoreCase("NVL").opaque("NVL"))
  private[parser] val ODD = P(IgnoreCase("ODD").opaque("ODD"))
  private[parser] val OF = P(IgnoreCase("OF").opaque("OF"))
  private[parser] val ONEOF = P(IgnoreCase("ONEOF").opaque("ONEOF"))
  private[parser] val OPTIONAL = P(IgnoreCase("OPTIONAL").opaque("OPTIONAL"))
  private[parser] val OR = P(IgnoreCase("OR").opaque("OR"))
  private[parser] val OTHERWISE = P(IgnoreCase("OTHERWISE").opaque("OTHERWISE"))
  private[parser] val PI = P(IgnoreCase("PI").opaque("PI"))
  private[parser] val PROCEDURE = P(IgnoreCase("PROCEDURE").opaque("PROCEDURE"))
  private[parser] val QUERY = P(IgnoreCase("QUERY").opaque("QUERY"))
  private[parser] val REAL = P(IgnoreCase("REAL").opaque("REAL"))
  private[parser] val REFERENCE = P(IgnoreCase("REFERENCE").opaque("REFERENCE"))
  private[parser] val REMOVE = P(IgnoreCase("REMOVE").opaque("REMOVE"))
  private[parser] val RENAMED = P(IgnoreCase("RENAMED").opaque("RENAMED"))
  private[parser] val REPEAT = P(IgnoreCase("REPEAT").opaque("REPEAT"))
  private[parser] val RETURN = P(IgnoreCase("RETURN").opaque("RETURN"))
  private[parser] val ROLESOF = P(IgnoreCase("ROLESOF").opaque("ROLESOF"))
  private[parser] val RULE = P(IgnoreCase("RULE").opaque("RULE"))
  private[parser] val SCHEMA = P(IgnoreCase("SCHEMA").opaque("SCHEMA"))
  private[parser] val SELECT = P(IgnoreCase("SELECT").opaque("SELECT"))
  private[parser] val SELF = P(IgnoreCase("SELF").opaque("SELF"))
  private[parser] val SET = P(IgnoreCase("SET").opaque("SET"))
  private[parser] val SIN = P(IgnoreCase("SIN").opaque("SIN"))
  private[parser] val SIZEOF = P(IgnoreCase("SIZEOF").opaque("SIZEOF"))
  private[parser] val SKIP = P(IgnoreCase("SKIP").opaque("SKIP"))
  private[parser] val SQRT = P(IgnoreCase("SQRT").opaque("SQRT"))
  private[parser] val STRING = P(IgnoreCase("STRING").opaque("STRING"))
  private[parser] val SUBTYPE = P(IgnoreCase("SUBTYPE").opaque("SUBTYPE"))
  private[parser] val SUBTYPE_CONSTRAINT = P(IgnoreCase("SUBTYPE_CONSTRAINT").opaque("SUBTYPE_CONSTRAINT"))
  private[parser] val SUPERTYPE = P(IgnoreCase("SUPERTYPE").opaque("SUPERTYPE"))
  private[parser] val TAN = P(IgnoreCase("TAN").opaque("TAN"))
  private[parser] val THEN = P(IgnoreCase("THEN").opaque("THEN"))
  private[parser] val TO = P(IgnoreCase("TO").opaque("TO"))
  private[parser] val TOTAL_OVER = P(IgnoreCase("TOTAL_OVER").opaque("TOTAL_OVER"))
  private[parser] val TRUE = P(IgnoreCase("TRUE").opaque("TRUE"))
  private[parser] val TYPE = P(IgnoreCase("TYPE").opaque("TYPE"))
  private[parser] val TYPEOF = P(IgnoreCase("TYPEOF").opaque("TYPEOF"))
  private[parser] val UNIQUE = P(IgnoreCase("UNIQUE").opaque("UNIQUE"))
  private[parser] val UNKNOWN = P(IgnoreCase("UNKNOWN").opaque("UNKNOWN"))
  private[parser] val UNTIL = P(IgnoreCase("UNTIL").opaque("UNTIL"))
  private[parser] val USE = P(IgnoreCase("USE").opaque("USE"))
  private[parser] val USEDIN = P(IgnoreCase("USEDIN").opaque("USEDIN"))
  private[parser] val VALUE = P(IgnoreCase("VALUE").opaque("VALUE"))
  private[parser] val VALUE_IN = P(IgnoreCase("VALUE_IN").opaque("VALUE_IN"))
  private[parser] val VALUE_UNIQUE = P(IgnoreCase("VALUE_UNIQUE").opaque("VALUE_UNIQUE"))
  private[parser] val VAR = P(IgnoreCase("VAR").opaque("VAR"))
  private[parser] val WHERE = P(IgnoreCase("WHERE").opaque("WHERE"))
  private[parser] val WHILE = P(IgnoreCase("WHILE").opaque("WHILE"))
  private[parser] val WITH = P(IgnoreCase("WITH").opaque("WITH"))
  private[parser] val XOR = P(IgnoreCase("XOR").opaque("XOR"))
}